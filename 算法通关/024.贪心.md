# 贪心

​	贪心是一个非常庞大的算法设计思想，其最符合人类的自然智慧。当然难度高的贪心往往需要配合数学证明。贪心的难点就在于如何从局部最优证明全局最优。

​	狭义贪心就是：每一步都做出在当前状态下最好或最优的选择，从而希望最终的结果是最好或最优的算法。

​	广义贪心就是：通过分析题目自身特点和性质，只要发现让求解答案的过程得到加速的结论，都算贪心。

​	但是什么样的题目是贪心算法可以解决的题目？不知道！一些简单的贪心题目可能一眼就看出，复杂的贪心很难看出。

## 什么是贪心

​	题目链接：https://leetcode.cn/problems/largest-number/

​	这题要求数字，但是更广义的是字符串。也就是给定任意几个字符串，返回拼接后字典序最小的结果。此题能否按每个字符串的字典序来排序再按顺序拼接呢？不行。反例："b"、"ba"，如果按字典序排序结果是："b" + "ba"，但是其实最优解是："ba" + "b"。所以我们应该比较两个字符串拼接后的大小关系。假设这里有两个字符串s1和s2，返回拼接后字典序最小，那么要么是s1+s2，要么是s2+s1，只需比较一下就可以了。推广到若干个字符串呢？我们是否可以按照这个策略来排序？这就需要一个证明：假设有三个字符串s1，s2，s3，比较s1和s2要比较拼接后的大小，比较s2和s3也要比较它俩拼接后的大小，得出的结论有传递性。如果能证明有传递性，我们就可以按照两个字符串拼接比大小的方式排序，否则就不行。什么是传递性？就是 s1+s2 <= s2+s1 且 s2+s3 <= s3+s2 能否推出s1+s3 <= s3+s1？能推出就有传递性，否则没有。类比于1 < 2 且 2 < 3，就能推出1 < 3。下面证明该传递性。

​	比如有两个字符串"ab"和"cde"，二者拼接字典序最小是"abcde"，这个过程可以看作：将"ab"放在高位，再加上字符串"cde"，看成是数字的拼接，比如二进制或十进制，十进制举例子，想要12345这个数字，可以看成：12 * 1000 + 345，在十进制下，想变成高位就要乘以该进制的k次方，其中k是后面数字的长度。对于字符串，可以看作26进制的数字，所以s1拼接s2就可以写作：s1 * f(s2) + s2，这里的f(s2)函数的作用就是返回 26的s2的长度次方。相当于将s1放到高位，再加上s2就完成了拼接。我们把 s1+s2 <= s2+s1 且 s2+s3 <= s3+s2 这个条件写成该形式，有：s1 * f(s2) + s2 <= s2 * f(s1) + s1 且 s2 * f(s3) + s3 <= s3 * f(s2) + s2。将第一个式子减去s2，再乘以s3，第二个式子减去s2，再乘以s1。这里读者可以自行手写推导，容易计算，同时所有数字非负，不用担心不等号方向改变的问题，得出：s1 * f(s2) * s3 <= (s2 * f(s1) + s1 - s2) * s3 且 (s2 * f(s3) + s3 - s2) * s1 <= s3 * f(s2) * s1。观察到两个式子有一样的部分，可以将两不等式合并，得：s2 * f(s3) * s1 + s1 * s3 - s2 * s1 <= s2 * f(s1) * s3 + s1 * s3 - s2 * s3。再化简得：f(s3) * s1 + s3 <= f(s1) * s3 + s1，该式子就是s1+s3 <= s3+s1，传递性证毕。

​	自此，我们回到若干字符串的、按照拼接规则排好序的数组中，我们可以说：前面的某个字符串s1与后面某个字符串s2存在这样的关系：s1+s2 <= s2+s1。推广下去，我们的贪心策略就是将数组排序，按什么排序？按拼接大小排序。这样做按顺序拼接起来就是字典序最小的结果！这种贪心证明只能算普通的、很正常的，但是需要严格的数学证明一些推论的使用。考场上的人实力都很强，它们就算对于一些较难的贪心策略也有可能一眼看出，或者猜对。那么需要他们证明某些贪心策略是正确的那些题目，一定非常难！同样的，证明难度也是非常难，考场现推根本来不及！直接写对数器验证，对同一问题使用暴力、贪心策略两种方法，数据使用大规模的随机生成方式验证，就能保证贪心策略的正确性，虽然写暴力，但是绝大部分情况要比证明某些结论要方便的多！

​	此题C++代码如下，每种语言自定义排序函数写法不同，仅供参考：

```c++
string largestNumber(vector<int>& nums)
{
    sort(nums.begin(), nums.end(), [](const int &x, const int &y) { return to_string(x) + to_string(y) > to_string(y) + to_string(x); });
    string ans = "";
    if(nums[0] == 0)
    {
        return "0";
    }
    for(int x : nums)
    {
        ans += to_string(x);
    }
    return ans;
}
```

### 贪心的提醒

​	不要纠结严格证明，掌握对数器验证技巧。如果解法只包含贪心算法，那么代码量都不大。贪心的题目需要大量积累经验，这样的在面对其他贪心或者更复杂的贪心时，能够培养直觉，这往往取决于对题目特征的理解。贪心与dp有时很难区分，这里推荐，能不贪就不贪，观察好数据量，这样做比较稳，但是要求对其他算法例如dp的使用足够娴熟。贪心很容易结合其他算法出题，这时的贪心往往通过以前的经验和自然智慧想清楚，不纠结证明。另外关于笔试面试，贪心在笔试中容易出现，面试中不太容易出现。另外，贪心常常结合排序和堆来实现，做题时好好体会。

### 练习题目

​	https://leetcode.cn/problems/two-city-scheduling/ （一般+）

​	https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/ （一般++，贪心+记忆化搜索，此题贪心加速dp过程）

​	https://leetcode.cn/problems/meeting-rooms-ii/ （力扣会员题，下一个题目与该题相同）

​	https://www.nowcoder.com/practice/1ae8d0b6bb4e4bcdbf64ec491f63fc37 （一般+）

​	https://leetcode.cn/problems/course-schedule-iii/ （一般++，反悔贪心）

​	https://leetcode.cn/problems/minimum-cost-to-connect-sticks/ （力扣会员题，下一个题目与该题相同）

​	https://www.luogu.com.cn/problem/P1090 （容易++，贪心+堆，该贪心策略就是大名鼎鼎的哈夫曼编码使用的贪心策略）

​	https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/ （一般++，此题需要找到正确的贪心策略）

​	https://leetcode.cn/problems/integer-break/ （同上题）

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

​	补充一道大厂真题，没有在线链接：同上题，但是额外的要求是：一定分成k份，返回最大乘积。思路就是平均分，有些可能比其他的多1，这样分是最优的。比如n = 10，分成4份，那就是3 * 3 * 2 * 2。10/4 = 2，平均值为4个2，但是10%4=2，说明有两个数字需要+1。这样做就是最优的，有时间可以自行证明，建议写暴力方法然后对数器验证。给出代码：

```c++
int f_tanxin(int n, int k)
{
	int mod = 1000000007;
    long long a = n / k;
    int b = n % k;
    long long ans1 = qpower(a + 1, b, mod);
    long long ans2 = qpower(a, k - b, mod);
    return (int) (ans1 * ans2) % mod;
}

long long qpower(int num, int p, int mod)
{
    long long ans = 1;
    long long x = num;
    while(p > 0)
    {
        if(p & 1) ans = (ans * x) % mod;
        x = (x * x) % mod;
        p >>= 1;
    }
    return ans;
}
```

​	下面给出暴力解代码用于测试验证：

```c++
int f_baoli(int n, int k)
{
    return f(n, k);
}

//剩余长度rest，还需分k份
int f(int rest, int k)
{
    if(k == 1) return rest;
    int ans = INT_MIN;
    for(int cur = 1; cur <= rest && (rest - cur) >= (k - 1); cur++)
    {
        int curans = cur * f(rest - cur, k - 1);
        ans = max(ans, curans);
    }
    return ans;
}
```

​	自己写随机数生成，验证二者答案是否一致即可。

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

​	https://leetcode.cn/problems/non-overlapping-intervals/ （一般）

​	https://www.luogu.com.cn/problem/P1803 （一般）

​	https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/ （一般）

​	https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/ （一般+）

​	https://leetcode.cn/problems/ipo/ （一般+）

​	https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/ （一般+）

​	https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/ （一般+）

​	https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/ （一般++）

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

​	补充一道大厂真题，培养一下灵感：

​	给定一个数组arr，长度为n。再给定一个数字k，表示一定要将arr划分为k个集合，每个数字只能进入一个集合。返回每个集合平均值都累加起来的最小值。1 <= n <= 10^5，0 <= arr[i] <= 10^5， 1 <= k <= n。

​	这题如果不去贪心，思考难度还是较大的，且数据范围较大。

​	这道题目的贪心策略：先将arr从小到大排序，前k - 1个数每个数单独作为一个集合，剩下的n - k + 1个数作为最后一个集合，这样的结果最小。证明比较麻烦，感兴趣自行搜索。

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

​	https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/ （一般++，单一维度贪不下去，试试组合起来）

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

​	补充一道大厂真题，培养一下灵感：

​	给出一个长度为n的01串，现在请你找到两个区间，使得这两个区间中，1的个数相等，0的个数也相等。这两个区间可以相交，但是不可以完全重叠，即两个区间的左右端点不可以完全一样。现在请你找到两个最长的区间，满足以上要求，返回区间最大长度。

​	贪心策略：找到最左侧的0和最右侧的0，中间的是两个区间共用部分，第一个区间包含左侧的0，第二个区间包含右侧的0，记录该区间长度。同理，再找到最左侧的1和最右侧的1，两种情况的最大值就是答案。

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

​	https://leetcode.cn/problems/minimize-deviation-in-array/ （一般++）

​	https://leetcode.cn/problems/rabbits-in-forest/ （一般++）

​	https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/ （一般++）

​	https://www.nowcoder.com/practice/2a9089ea7e5b474fa8f688eae76bc050 （较难）

​	https://leetcode.cn/problems/divide-array-into-increasing-sequences/ （一般++，力扣会员题，没米，暂未解决）

​	https://leetcode.cn/problems/minimum-number-of-refueling-stops/ （一般++，反悔贪心）

​	https://leetcode.cn/problems/jump-game-ii/ （一般++）

​	https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/ （一般++，大体思路同上题，有一些细节需要处理）

​	https://leetcode.cn/problems/string-transforms-into-another-string/ （一般++，力扣会员题，暂未解决）

​	https://www.luogu.com.cn/problem/P1809 （一般++，贪心+dp（两种贪心策略pk最优解））

​	https://leetcode.cn/problems/super-washing-machines/ （一般++）

​	https://leetcode.cn/problems/largest-palindromic-number/ （一般++，这题难度不大，但是细节繁多）

​	https://leetcode.cn/problems/maximum-average-pass-ratio/ （一般+）

​	https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/ （一般++）

​	