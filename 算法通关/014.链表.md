# 链表

## 链表基本概念

​	链表是一种线性数据结构，一个连着一个，查找的时候也只能逐个遍历下去，不支持索引访问（随机访问）。对于一个节点来说，他除了保存的数据，还需要保存下一个节点的地址，以便于能访问到下一个节点。

​	对于链表头，可以加也可以不加，这里需要不同的处理方式。如果加了链表头，那么所有有效的节点都有前驱和后继，当然除了最后一个节点，也可以看作最后一个节点的后继是空指针，这样对于所有有效节点的处理就都一样了。同时头结点还可以存储一些额外的信息，比如链表长度，这样在获取链表长度时就不用遍历一遍获取了。如果不加链表头，那么第一个节点中就存储了有效信息，需要先处理再前往下一个节点。

​	这里给出完整的链表数据结构的实现（C++），其余种类链表读者可以自行参考实现。

```c++
#include <iostream>
using namespace std;

typedef int EleType;

struct LinkedList
{
	EleType data;
	LinkedList* next;
};

//链表初始化
void init(LinkedList*& ls)
{
	LinkedList* node = new LinkedList;
	node->next = nullptr;
	ls = node;
}

//计算链表长度
int length(LinkedList* ls)
{
	int cnt = 0;
	while (ls->next != nullptr)
	{
		ls = ls->next;
		cnt++;
	}

	return cnt;
}

//链表的插入，在第pos个位置后插入
void insert(LinkedList*& ls, int pos, EleType value)
{
	if (pos < 0 || pos > length(ls))
	{
		cout << "输入位置不合法！" << endl;
		exit(-1);
	}
	LinkedList* p = ls;
	int cnt = 0;
	while (p->next != nullptr)
	{
		cnt++;
		p = p->next;
		if (cnt == pos)
		{
			break;
		}
	}

	LinkedList* node = new LinkedList;
	node->data = value;
	node->next = p->next;
	p->next = node;
}

//链表的删除，删除第pos个元素
void dele(LinkedList*& ls, int pos)
{
	if (pos <= 0 || pos > length(ls))
	{
		cout << "输入位置不合法！" << endl;
		exit(-1);
	}
	if (length(ls) == 0)
	{
		cout << "无元素，不可删除！" << endl;
		exit(-1);
	}
	else
	{
		//找到第pos个元素的前一个元素，记录下来地址
		LinkedList* p = ls;
		for (int i = 0; i < pos - 1; i++)
		{
			p = p->next;
		}
		LinkedList* temp = p->next;
		LinkedList* q = temp->next;

		p->next = q;
		delete temp;
	}
}

//链表的查找，如果找到了返回是第几个元素，没找到返回-1
int find(LinkedList* ls, EleType value)
{
	int cnt = 0;
	while (ls->next != nullptr)
	{
		ls = ls->next;
		cnt++;
		if (ls->data == value)
		{
			return cnt;
		}
	}

	return -1;
}

//链表的索引，返回第pos个元素的值
int get(LinkedList* ls, int pos)
{
	if (pos <= 0 || pos > length(ls))
	{
		cout << "输入位置不合法！" << endl;
		exit(-1);
	}

	for (int i = 0; i < pos; i++)
	{
		ls = ls->next;
	}

	return ls->data;
}

//链表的修改，将第pos个元素值修改为value
void update(LinkedList*& ls, int pos, EleType value)
{
	if (pos <= 0 || pos > length(ls))
	{
		cout << "输入位置不合法！" << endl;
		exit(-1);
	}

	LinkedList* p = ls;
	for (int i = 0; i < pos; i++)
	{
		p = p->next;
	}

	p->data = value;
}

//链表的打印
void print(LinkedList* ls)
{
	if (length(ls) == 0)
	{
		cout << "链表为空！" << endl;
		exit(-1);
	}
	while (ls->next != nullptr)
	{
		ls = ls->next;
		cout << ls->data << " ";
	}
	cout << endl;
}

//链表的销毁
void destroy(LinkedList*& ls)
{
	if (!length(ls))
	{
		cout << "链表已空！" << endl;
		exit(-1);
	}
	
	while (ls->next != nullptr)
	{
		LinkedList* p = ls->next;
		delete ls;
		ls = p;
	}
}

int main()
{
	LinkedList* ls{};
	init(ls);

	cout << "链表初始长度：" << length(ls) << endl;
	insert(ls, 0, 1);
	insert(ls, 1, 2);
	insert(ls, 2, 3);
	cout << "链表长度：" << length(ls) << endl;
	print(ls);

	/*
	* 元素的删除
	dele(ls, 3);
	cout << "链表长度：" << length(ls) << endl;
	print(ls);
	*/

	/*
	* 元素的查找
	int ans = find(ls, 2);
	if (ans == -1)
	{
		cout << "未找到该值！" << endl;
	}
	else
	{
		cout << ans << endl;
	}
	*/

	/*
	* 元素索引
	int ans = get(ls, 1);
	cout << "第一个值为：" << ans << endl;
	*/

	/*
	* 元素的修改
	update(ls, 3, 4);
	cout << "链表长度：" << length(ls) << endl;
	print(ls);
	*/

	destroy(ls);

	return 0;
}
```

​	上述代码没有使用C++的class封装。

## 链表的反转

​	这是一道经典题目，实现方式也可以有多种。

## 练习题目

​	*注：虽然题目分类了，但是类别之间难免交叉使用，例如删除链表中的某些元素时，不可避免地要遍历链表。*

### 遍历链表

​	https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/ （容易+）

​	https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/ （容易++）

​	https://leetcode.cn/problems/merge-nodes-in-between-zeros/ （容易++）

​	https://leetcode.cn/problems/split-linked-list-in-parts/ （容易++）

​	https://leetcode.cn/problems/linked-list-components/ （容易++）

### 删除节点

​	https://leetcode.cn/problems/remove-linked-list-elements/ （容易+）

​	https://leetcode.cn/problems/delete-nodes-from-linked-list-present-in-array/ （容易+，这题不能delete）

​	https://leetcode.cn/problems/remove-duplicates-from-sorted-list/ （容易+）

​	https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/ （容易++）

​	https://leetcode.cn/problems/delete-node-in-a-linked-list/ （容易++）

​	