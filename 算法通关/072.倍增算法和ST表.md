# 倍增算法基础和ST表

*前置知识：二进制与位运算、动态规划基础*

​	先来思考两个小问题：

​		1、打印一个整数的二进制状态；

​		2、求一个2的整数次方，它是小于等于x的、最接近x的整数。

## ST表（稀疏表）最经典的应用

​	线段上有n个点，给定每个点 i 往右跳一步能最远覆盖的点jump[i]。已知：从任意点出发都能到达最后的点，并且在 i < j 时，必有jump[i] <= jump[j]。

​	对于这个模型，我们有两个需求：

​		1、如何构建一张表，使得：可以查询从任意点出发，跳1步、2步、...、也就是2的p次方步，最远能到达的点；

​		2、如何快速计算任意两点之间，最少跳几步能到达。

​	构建出来的表就叫做ST表。

​	构建方式：st[i] [p] = st[ st[i] [p-1] ] [p-1]. 其中p代表：2的p次方步，该表是二维的，表大小是n*logn，表示 i 这个点跳2的p次方步最远到达的点。

​	填表的过程：首先，st[i] [0]这一列代表从 i 这个点跳1步最远能到哪，这就是题目给定的输入，即：st[i] [0] = jump[i]；其余格子就按照构建方式来填，那么这个式子是什么意思呢？实际上就是将跳跃过程拆分为两次，每次跳2的p-1次方步，想得到从 i 位置跳2的p次方步最远到达的位置，等价于先从 i 位置跳2的p-1次方步最远到达的位置，再从该位置跳2的p-1次方步最远到达的位置。为什么可以拆，题目给定了单调性，也就是后面的点能到达的最远位置一定大于等于前面的点能到达的最远位置。通过递推式可以看出：每个位置只依赖于它左侧的格子。

​	现在解决了需求1，再来看看需求2怎么解决。这里给出一个例子帮助理解：

​	想求：17到77最少需要几步。如果一个一个跳，最多也就77-17=60步。所以二进制6位（0~63）就能表示得下该步数。这六位二进制的信息分别是32、16、8、4、2、1。我们先来看，从17位置跳32（2的5次方）步最远能到哪，这个信息在st表中存储，直接查询即可，注意：要查st[17] [5]，而不是st[17] [32]。假设st[17] [5] = 105，105大于目的点77，所以32步不要，六位二进制对应位标0。这里注意，大于等于目的点的我们都不要，只要严格小于目的点的值。再看从17位置跳16（2的4次方）步最远能到哪，假设st[17] [4] = 49，我们就要这步，二进制标1。现在要的问题变成：从49到77，最少需要几步，还是查询st表，查：st[49] [3]，假设这个值为94，大于77，不要，二进制位标0。再看st[49] [2]，假设值为83，也不要，标0。假设st[49] [1] = 70，小于77，标1。再看st[70] [0]，假设值为73，小于77，标1。最后从73到77只需加一步就能到达。这是为什么呢？这样理解：以上求解过程，实际上是尽可能靠近77，但是又不能等于或者超过77。最后到达73，一定是最逼近77的位置，如果73到77还需要大于1步，那么这个位置就不是尽可能逼近的位置，换句话说，前面决策的过程中，一定还可以更接近77。时间复杂度为O(logn)。

​	练习题目：https://www.luogu.com.cn/problem/P4155

​	这道题目不算模板题，因为还需要一点转化。左老师视频题解：https://www.bilibili.com/video/BV1At421A7UP/?spm_id_from=333.1387.collection.video_card.click&vd_source=7c086dbd9bbae83af621881fef428272看1就是本题。

​	以下是文字版题解：如何转化为刚才探讨的问题？首先对于环的问题，我们肯定需要扩充一倍来解决。这样覆盖环的问题就变为从 i 位置看需要几条线段能到 i + m 位置，这里我们把线段的编号看成点，st[i] [p]表示：从i号线段，跳2的p次方步最远能到几号线段。跳的时候怎么跳最远？当前线段能覆盖的其它线段的开头位置最靠右的，按照这条线段跳就是最远，因为有单调性。这样问题变成：一定要包含第 i 条线段，假设它的开始位置为s，那么我们要经过最少的线段（跳的次数最少）到达s + m这个位置，可能是被第 j 跳线段覆盖的，也就是从 i 到 j 最少需要跳几步，问题就转化为上面讲述的过程了。AC代码如下：

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n, m;
vector<vector<int>> line(400005, vector<int>(3));
int power;
int st[200005 << 1][18]; // n不会超过2的18次方
int ans[200005];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
    {
        cin >> line[i][1] >> line[i][2];
        if(line[i][1] > line[i][2]) line[i][2] += m; // 发现扣圈就处理一下右端点，使之变为一条数轴上的问题
        line[i][0] = i;
    }
    sort(line.begin() + 1, line.begin() + 1 + n, [](auto& a, auto& b) { return a[1] < b[1]; }); // 按线段开头位置排序
    // 将线段扩充一倍，以解决环的问题
    for(int i = 1; i <= n; i++)
    {
        line[i + n][0] = line[i][0];
        line[i + n][1] = line[i][1] + m;
        line[i + n][2] = line[i][2] + m;
    }

    // 求最近接n的是2的power次幂，st表就有power列
    while((1 << power) <= (n >> 1)) power++;

    // 接下来求st表
    int e = n << 1; // 扩充后线段条数翻倍
    // 先求第0列，就是i号线段一步最远能到达几号线段，肯定是i号线段包括的所有线段开头中最右的
    for(int i = 1, r = 1; i <= e; i++)
    {
        while(r + 1 <= e && line[r + 1][1] <= line[i][2]) r++;
        st[i][0] = r;
    }
    // 求整个st表
    for(int p = 1; p <= power; p++)
    {
        for(int i = 1; i <= e; i++) st[i][p] = st[st[i][p - 1]][p - 1];
    }

    for(int i = 1; i <= n; i++)
    {
        int aim = line[i][1] + m; // 目标是绕一圈
        int cur = i, next; // cur表示当前到第几号线段，next表示当前线段跳若干步之后能到第几号线段
        int sum = 1; // 一共需要跳sum步，初始化为1是因为：起始线段需要额外计数
        for(int p = power; p >= 0; p--)
        {
            next = st[cur][p];
            if(next != 0 && line[next][2] < aim)
            {
                sum += 1 << p;
                cur = next;
            }
        }
        ans[line[i][0]] = sum + 1; // 最后再加一步，可以到达目标地点
    }

    for(int i = 1; i <= n; i++) cout << ans[i] << " ";
    
    return 0;
}
```

## ST表维护更多信息

### ST表维护区间最值

​	例题：https://www.luogu.com.cn/problem/P2880

​	该题是利用ST表来维护**区间最值**的。我们来看看如何做到。先看最大值：

​	st[i] [p] 表示：从 i 位置开始，包括 i 位置，往后数2的 p 次方个位置，这段区间的最大值是多少。对于第一列，st[i] [0]来说，从 i 位置开始，往后数2的0次方个，其实就是这个数字本身，所以第0列的数字都很容易填。对于一个普遍的格子来讲，如何推呢？st[i] [p] = max(st[i] [p - 1], st[i + 2^(p-1)] [p - 1])。这个式子就是拆解，例如，求p = 3时，也就是从 i 位置往后数8个位置，这段区间的最大值，它等同于从 i  位置开始，往后数4个位置的最大值，与从 i 位置往后数4个位置开始，再往后数4个位置的最大值，二者取最大就是答案。本质上就是[1, 8]上的最大值 = max( [1, 4]的最大值, [5, 8]的最大值 )。

​	那么有了st表，对于任意区间最大值的查询就变得异常方便。举个例子演示如何求解，例如：想求区间[17, 37]上的最大值，这个区间中有21个下标，最接近它的2的幂是16，问题可以拆解为：max( [17, 32], [22, 37] )，其中，这两个区间都包含16个下标，虽然有重复区间，但是求最大值是无所谓的，这样直接查ST表：st[17] [4]与st[22] [4]，二者最大值即为原区间最大值。求解该问题时，需要知道求解区间长度，求一个最接近的2的幂，假设为m，使之不超过区间长度，然后计算区间右边界左侧m个长度，pk出最大值即可。

​	对于最小值也是同理。

​	例题AC代码如下：

```c++
#include <iostream>
using namespace std;

int n, q;
int a[50005];
int stmax[50005][16];
int stmin[50005][16];
int log2[50005];

int query(int l, int r)
{
    int p = log2[r - l + 1];
    int mx = max(stmax[l][p], stmax[r - (1 << p) + 1][p]);
    int mn = min(stmin[l][p], stmin[r - (1 << p) + 1][p]);
    return mx - mn;
}

int main()
{
    cin >> n >> q;
    for(int i = 1; i <= n; i++) cin >> a[i];

    log2[0] = -1;
    for(int i = 1; i <= n; i++)
    {
        log2[i] = log2[i >> 1] + 1;
        stmax[i][0] = a[i];
        stmin[i][0] = a[i];
    }
    for(int p = 1; p <= log2[n]; p++)
    {
        for(int i = 1; i + (1 << p) - 1 <= n; i++)
        {
            stmax[i][p] = max(stmax[i][p - 1], stmax[i + (1 << (p - 1))][p - 1]);
            stmin[i][p] = min(stmin[i][p - 1], stmin[i + (1 << (p - 1))][p - 1]);
        }
    }
    
    for(int i = 1, l, r; i <= q; i++)
    {
        cin >> l >> r;
        cout << query(l, r) << "\n";
    }
    
    return 0;
}
```

### ST表维护区间gcd

​	例题：https://www.luogu.com.cn/problem/P1890

​	原理同上，AC代码如下：

```c++
#include <iostream>
#include <numeric>
using namespace std;

int n, m;
int a[1005];
int st[1005][10];
int log2[1005];

int query(int l, int r)
{
    int p = log2[r - l + 1];
    return gcd(st[l][p], st[r - (1 << p) + 1][p]);
}

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i];
    log2[0] = -1;
    for(int i = 1; i <= n; i++)
    {
        log2[i] = log2[i >> 1] + 1;
        st[i][0] = a[i];
    }
    for(int p = 1; p <= log2[n]; p++)
    {
        for(int i = 1; i + (1 << p) - 1 <= n; i++)
        {
            st[i][p] = gcd(st[i][p - 1], st[i + (1 << (p - 1))][p - 1]);
        }
    }
    
    for(int i = 1, l, r; i <= m; i++)
    {
        cin >> l >> r;
        cout << query(l, r) << "\n";
    }
    
    return 0;
}
```

## ST表的适用范围

​	如果A区间和B区间有重叠的部分，但是不影响A+B区间的答案，换句话说，A+B区间的答案可以由A区间和B区间的答案加工出来。对应的区间询问，就是一个可重复贡献问题。例如：区间最值、区间公约数、区间按位与、区间按位或等，但是区间求和就不行。

## ST表的优势和劣势

​	RMQ（Range Maximum/Minimum Query）问题可以用ST表维护，也可以用线段树等结构维护。

​	ST表的优势：构建过程时间复杂度为O(nlogn)，单次查询时间复杂度O(1)，代码量小；

​	ST表的劣势：需要空间较大，能维护的信息非常有限，不支持修改操作。

## 练习题目

​	https://vjudge.net/problem/UVA-11235 （一般++，需要将问题稍微转化一下）

​	